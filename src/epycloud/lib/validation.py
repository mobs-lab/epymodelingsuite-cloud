"""Input validation functions for epycloud CLI.

This module provides validation functions for user inputs to ensure security
and correctness. All validation functions raise ValidationError on invalid input.
"""

import re
import subprocess
from pathlib import Path

from epycloud.exceptions import ValidationError


def validate_exp_id(exp_id: str) -> str:
    """Validate and sanitize experiment ID.

    Experiment IDs must contain only alphanumeric characters, dashes, underscores,
    and forward slashes (for nested directories). Path traversal attempts are rejected.

    Parameters
    ----------
    exp_id : str
        Experiment ID to validate. Can include directory path (e.g., "test/my-exp-01").

    Returns
    -------
    str
        Validated and trimmed experiment ID.

    Raises
    ------
    ValidationError
        If exp_id is empty, contains invalid characters, or is too long.

    Examples
    --------
    >>> validate_exp_id("test-sim-2024")
    'test-sim-2024'
    >>> validate_exp_id("  my_exp_01  ")
    'my_exp_01'
    >>> validate_exp_id("test/my-exp-01")
    'test/my-exp-01'
    >>> validate_exp_id("../etc/passwd")
    Traceback (most recent call last):
        ...
    ValidationError: Invalid experiment ID: ../etc/passwd. Path traversal not allowed
    """
    if not exp_id or not exp_id.strip():
        raise ValidationError("Experiment ID cannot be empty")

    exp_id = exp_id.strip()

    # Check for path traversal attempts (.. or backslashes)
    if ".." in exp_id or "\\" in exp_id:
        raise ValidationError(f"Invalid experiment ID: {exp_id}. Path traversal not allowed")

    # Must be alphanumeric + dash/underscore/forward-slash only
    if not re.match(r"^[a-zA-Z0-9_/-]+$", exp_id):
        raise ValidationError(
            f"Invalid experiment ID: {exp_id}. Must contain only letters, numbers, dash, underscore, and forward slash"
        )

    # Reasonable length limit
    if len(exp_id) > 200:
        raise ValidationError(f"Experiment ID too long: {len(exp_id)} chars (max 200)")

    return exp_id


def validate_run_id(run_id: str) -> str:
    """Validate run ID format.

    Run IDs follow the format generated by Cloud Workflows:
    YYYYMMDD-HHMMSS-xxxxxxxx

    Where:
    - YYYYMMDD: 8-digit date (e.g., 20251107)
    - HHMMSS: 6-digit time (e.g., 143052)
    - xxxxxxxx: 8-character UUID prefix (lowercase hex)

    The validation also accepts user-defined alphanumeric IDs for local runs.

    Parameters
    ----------
    run_id : str
        Run ID to validate.

    Returns
    -------
    str
        Validated and trimmed run ID.

    Raises
    ------
    ValidationError
        If run_id is empty, has invalid format, or is too long.

    Examples
    --------
    >>> validate_run_id("20251107-143052-a1b2c3d4")
    '20251107-143052-a1b2c3d4'
    >>> validate_run_id("my-local-run-01")
    'my-local-run-01'
    >>> validate_run_id("2025-11-07")
    Traceback (most recent call last):
        ...
    ValidationError: Invalid run ID format: 2025-11-07. Expected
        YYYYMMDD-HHMMSS-xxxxxxxx or alphanumeric with dash/underscore
    """
    if not run_id or not run_id.strip():
        raise ValidationError("Run ID cannot be empty")

    run_id = run_id.strip()

    # Check for standard workflow format: YYYYMMDD-HHMMSS-xxxxxxxx
    workflow_pattern = r"^\d{8}-\d{6}-[a-f0-9]{8}$"
    if re.match(workflow_pattern, run_id):
        # Validate date and time components make sense
        date_part = run_id[:8]
        time_part = run_id[9:15]

        # Basic date validation (YYYYMMDD)
        year = int(date_part[:4])
        month = int(date_part[4:6])
        day = int(date_part[6:8])

        if year < 2020 or year > 2100:
            raise ValidationError(f"Invalid year in run ID: {year}")
        if month < 1 or month > 12:
            raise ValidationError(f"Invalid month in run ID: {month}")
        if day < 1 or day > 31:
            raise ValidationError(f"Invalid day in run ID: {day}")

        # Basic time validation (HHMMSS)
        hour = int(time_part[:2])
        minute = int(time_part[2:4])
        second = int(time_part[4:6])

        if hour > 23:
            raise ValidationError(f"Invalid hour in run ID: {hour}")
        if minute > 59:
            raise ValidationError(f"Invalid minute in run ID: {minute}")
        if second > 59:
            raise ValidationError(f"Invalid second in run ID: {second}")

        return run_id

    # Allow user-defined alphanumeric IDs (for local runs)
    if re.match(r"^[a-zA-Z0-9_-]+$", run_id):
        if len(run_id) > 100:
            raise ValidationError(f"Run ID too long: {len(run_id)} chars (max 100)")
        return run_id

    # Neither format matched
    raise ValidationError(
        f"Invalid run ID format: {run_id}. "
        "Expected YYYYMMDD-HHMMSS-xxxxxxxx or alphanumeric with dash/underscore"
    )


def validate_local_path(path: Path, must_exist: bool = True, must_be_dir: bool = False) -> Path:
    """Validate local filesystem path.

    Resolves the path to absolute form and optionally checks existence.

    Parameters
    ----------
    path : Path
        Path to validate.
    must_exist : bool, default=True
        Require path to exist.
    must_be_dir : bool, default=False
        Require path to be a directory (only checked if path exists).

    Returns
    -------
    Path
        Validated, resolved absolute path.

    Raises
    ------
    ValidationError
        If path is invalid, doesn't exist (when required), or is not a
        directory (when required).

    Examples
    --------
    >>> validate_local_path(Path("."), must_exist=True, must_be_dir=True)
    PosixPath('/home/user/current-dir')
    >>> validate_local_path(Path("nonexistent"), must_exist=True)
    Traceback (most recent call last):
        ...
    ValidationError: Path does not exist: nonexistent
    """
    # Resolve to absolute path (handles symlinks, "..", etc.)
    try:
        resolved_path = path.resolve()
    except Exception as e:
        raise ValidationError(f"Invalid path: {path}. {e}")

    if must_exist and not resolved_path.exists():
        raise ValidationError(f"Path does not exist: {path}")

    if must_be_dir and resolved_path.exists() and not resolved_path.is_dir():
        raise ValidationError(f"Path is not a directory: {path}")

    return resolved_path


def validate_github_token(token: str) -> str:
    """Validate GitHub personal access token format.

    GitHub tokens start with specific prefixes depending on token type:
    - ghp_ : Classic personal access token
    - github_pat_ : Fine-grained personal access token
    - gho_ : OAuth access token
    - ghu_ : User-to-server token
    - ghs_ : Server-to-server token
    - ghr_ : Refresh token

    Parameters
    ----------
    token : str
        GitHub PAT to validate.

    Returns
    -------
    str
        Validated and trimmed token.

    Raises
    ------
    ValidationError
        If token is empty, has invalid format, or unusual length.

    Examples
    --------
    >>> validate_github_token("ghp_1234567890abcdef1234567890abcdef1234")
    'ghp_1234567890abcdef1234567890abcdef1234'
    >>> validate_github_token("github_pat_11AAAAAA0xxxxxxxxxxxxxxxxx_yyyyyyyyyyyyyyyyyy")
    'github_pat_11AAAAAA0xxxxxxxxxxxxxxxxx_yyyyyyyyyyyyyyyyyy'
    >>> validate_github_token("not-a-token")
    Traceback (most recent call last):
        ...
    ValidationError: Invalid GitHub token format. Expected to start with
        github_pat_, ghp_, gho_, ghu_, ghs_, or ghr_
    """
    if not token or not token.strip():
        raise ValidationError("GitHub token cannot be empty")

    token = token.strip()

    # GitHub tokens start with github_pat_, ghp_, gho_, etc.
    if not token.startswith(("github_pat_", "ghp_", "gho_", "ghu_", "ghs_", "ghr_")):
        raise ValidationError(
            "Invalid GitHub token format. "
            "Expected to start with github_pat_, ghp_, gho_, ghu_, ghs_, or ghr_"
        )

    # Reasonable length (GitHub PATs are typically 40-200 chars, fine-grained can be longer)
    if len(token) < 20 or len(token) > 300:
        raise ValidationError(f"GitHub token length unusual: {len(token)} chars")

    return token


def validate_stage_name(stage: str) -> str:
    """Validate pipeline stage name.

    Valid stage names are: builder, runner, output.

    Parameters
    ----------
    stage : str
        Stage name to validate.

    Returns
    -------
    str
        Validated stage name in lowercase.

    Raises
    ------
    ValidationError
        If stage name is invalid.

    Examples
    --------
    >>> validate_stage_name("builder")
    'builder'
    >>> validate_stage_name("RUNNER")
    'runner'
    >>> validate_stage_name("invalid")
    Traceback (most recent call last):
        ...
    ValidationError: Invalid stage name: invalid. Must be one of: builder, runner, output
    """
    if not stage or not stage.strip():
        raise ValidationError("Stage name cannot be empty")

    stage = stage.strip().lower()

    valid_stages = {"builder", "runner", "output"}
    if stage not in valid_stages:
        raise ValidationError(
            f"Invalid stage name: {stage}. Must be one of: {', '.join(sorted(valid_stages))}"
        )

    return stage


def sanitize_label_value(value: str) -> str:
    """Sanitize a string for use as a GCP label value.

    GCP labels have specific requirements:
    - Only lowercase letters, numbers, hyphens, and underscores
    - Must start with a letter or number
    - Max 63 characters

    Parameters
    ----------
    value : str
        The value to sanitize

    Returns
    -------
    str
        Sanitized label value

    Examples
    --------
    >>> sanitize_label_value("test/test-flu-projection-2025-01")
    'test-test-flu-projection-2025-01'
    >>> sanitize_label_value("20251118-061019-bfea55a4")
    '20251118-061019-bfea55a4'
    """
    # Replace forward slashes with hyphens (common in exp_id like "test/test-flu-projection")
    sanitized = value.replace("/", "-")

    # Replace any other invalid characters with hyphens
    sanitized = "".join(c if c.isalnum() or c in "-_" else "-" for c in sanitized)

    # Convert to lowercase
    sanitized = sanitized.lower()

    # Truncate to 63 characters if needed
    if len(sanitized) > 63:
        sanitized = sanitized[:63]

    # Ensure it doesn't start or end with hyphen/underscore
    sanitized = sanitized.strip("-_")

    return sanitized


def validate_machine_type(machine_type: str, project_id: str, region: str) -> str:
    """Validate Google Cloud machine type against available types in the region.

    Queries the Compute Engine API to verify that the specified machine type
    exists in the given region. Machine types are zone-specific, so this checks
    all zones in the region.

    Parameters
    ----------
    machine_type : str
        Machine type to validate (e.g., "n2-standard-4", "c2-standard-8").
    project_id : str
        Google Cloud project ID.
    region : str
        Google Cloud region (e.g., "us-central1").

    Returns
    -------
    str
        Validated machine type string.

    Raises
    ------
    ValidationError
        If machine type is empty, has invalid format, or doesn't exist in region.

    Examples
    --------
    >>> validate_machine_type("n2-standard-4", "my-project", "us-central1")
    'n2-standard-4'
    >>> validate_machine_type("invalid-machine", "my-project", "us-central1")
    Traceback (most recent call last):
        ...
    ValidationError: Machine type 'invalid-machine' not found in region us-central1
    """
    if not machine_type or not machine_type.strip():
        raise ValidationError("Machine type cannot be empty")

    machine_type = machine_type.strip()

    # Basic format validation (machine types are lowercase with dashes and numbers)
    if not re.match(r"^[a-z0-9]+-[a-z0-9-]+$", machine_type):
        raise ValidationError(
            f"Invalid machine type format: {machine_type}. "
            "Expected format like 'n2-standard-4' or 'c2-standard-8'"
        )

    # Query available machine types in the region using gcloud
    try:
        result = subprocess.run(
            [
                "gcloud",
                "compute",
                "machine-types",
                "list",
                f"--project={project_id}",
                f"--filter=zone~{region}",
                "--format=value(name)",
            ],
            capture_output=True,
            text=True,
            check=False,
            timeout=30,
        )

        if result.returncode != 0:
            # If gcloud fails, log warning but allow the machine type
            # (it might still be valid, just can't verify)
            raise ValidationError(
                f"Unable to validate machine type '{machine_type}': "
                f"gcloud command failed. Error: {result.stderr.strip()}"
            )

        # Parse available machine types
        available_types = set(result.stdout.strip().split("\n"))

        if machine_type not in available_types:
            # Provide helpful suggestions for similar machine types
            suggestions = [mt for mt in available_types if machine_type.split("-")[0] in mt][:5]
            suggestion_msg = ""
            if suggestions:
                suggestion_msg = f" Available similar types: {', '.join(sorted(suggestions))}"

            raise ValidationError(
                f"Machine type '{machine_type}' not found in region {region}.{suggestion_msg}"
            )

        return machine_type

    except subprocess.TimeoutExpired:
        raise ValidationError(
            f"Timeout while validating machine type '{machine_type}'. "
            "Check your network connection and gcloud configuration."
        )
    except FileNotFoundError:
        raise ValidationError(
            "gcloud CLI not found. Please install Google Cloud SDK to validate machine types."
        )


def get_machine_type_specs(machine_type: str, project_id: str, region: str) -> tuple[int, int]:
    """Query machine type specifications and return CPU and memory.

    Uses gcloud CLI to describe a machine type and extract its vCPU count and
    memory allocation. Automatically converts to milliCPU and MiB for use in
    Google Cloud Batch job configurations.

    Parameters
    ----------
    machine_type : str
        Machine type to query (e.g., "n2-standard-4", "c2-standard-8").
        Must be a valid machine type in the region.
    project_id : str
        Google Cloud project ID.
    region : str
        Google Cloud region (e.g., "us-central1").
        The function will query zone {region}-a.

    Returns
    -------
    tuple[int, int]
        Tuple of (cpu_milli, memory_mib):
        - cpu_milli: vCPU count converted to milliCPU (vCPUs * 1000)
        - memory_mib: Memory in MiB (converted from MB)

    Raises
    ------
    ValidationError
        If machine type query fails, JSON parsing fails, or response
        doesn't contain expected fields.

    Examples
    --------
    >>> get_machine_type_specs("n2-standard-4", "my-project", "us-central1")
    (4000, 16384)
    >>> get_machine_type_specs("c2-standard-8", "my-project", "us-central1")
    (8000, 32768)

    Notes
    -----
    This function queries the first zone in the region ({region}-a).
    Machine type specs are consistent across zones within a region.
    """
    import json

    # Query machine type specs from gcloud
    zone = f"{region}-a"
    try:
        result = subprocess.run(
            [
                "gcloud",
                "compute",
                "machine-types",
                "describe",
                machine_type,
                f"--project={project_id}",
                f"--zone={zone}",
                "--format=json",
            ],
            capture_output=True,
            text=True,
            check=False,
            timeout=30,
        )

        if result.returncode != 0:
            raise ValidationError(
                f"Failed to query machine type '{machine_type}' specs: "
                f"gcloud command failed. Error: {result.stderr.strip()}"
            )

        # Parse JSON response
        try:
            specs = json.loads(result.stdout)
        except json.JSONDecodeError as e:
            raise ValidationError(
                f"Failed to parse machine type specs for '{machine_type}': "
                f"Invalid JSON response. Error: {e}"
            )

        # Extract vCPU count and memory
        if "guestCpus" not in specs:
            raise ValidationError(
                f"Machine type specs for '{machine_type}' missing 'guestCpus' field. "
                f"Response: {result.stdout[:200]}"
            )
        if "memoryMb" not in specs:
            raise ValidationError(
                f"Machine type specs for '{machine_type}' missing 'memoryMb' field. "
                f"Response: {result.stdout[:200]}"
            )

        guest_cpus = specs["guestCpus"]
        memory_mb = specs["memoryMb"]

        # Convert to milliCPU and MiB
        # milliCPU = vCPUs * 1000 (e.g., 4 vCPUs = 4000 milliCPU)
        cpu_milli = int(guest_cpus * 1000)

        # Memory: MB to MiB conversion (1 MB = 0.9537 MiB)
        # For practical purposes in GCP, we treat them as equivalent
        memory_mib = int(memory_mb)

        return cpu_milli, memory_mib

    except subprocess.TimeoutExpired:
        raise ValidationError(
            f"Timeout while querying machine type '{machine_type}' specs. "
            "Check your network connection and gcloud configuration."
        )
    except FileNotFoundError:
        raise ValidationError(
            "gcloud CLI not found. Please install Google Cloud SDK to query machine type specs."
        )
