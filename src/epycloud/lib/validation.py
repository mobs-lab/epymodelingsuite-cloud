"""Input validation functions for epycloud CLI.

This module provides validation functions for user inputs to ensure security
and correctness. All validation functions raise ValidationError on invalid input.
"""

import re
from pathlib import Path

from epycloud.exceptions import ValidationError


def validate_exp_id(exp_id: str) -> str:
    """Validate and sanitize experiment ID.

    Experiment IDs must contain only alphanumeric characters, dashes, and
    underscores. Path traversal attempts are rejected.

    Parameters
    ----------
    exp_id : str
        Experiment ID to validate.

    Returns
    -------
    str
        Validated and trimmed experiment ID.

    Raises
    ------
    ValidationError
        If exp_id is empty, contains invalid characters, or is too long.

    Examples
    --------
    >>> validate_exp_id("test-sim-2024")
    'test-sim-2024'
    >>> validate_exp_id("  my_exp_01  ")
    'my_exp_01'
    >>> validate_exp_id("../etc/passwd")
    Traceback (most recent call last):
        ...
    ValidationError: Invalid experiment ID: ../etc/passwd. Path traversal not allowed
    """
    if not exp_id or not exp_id.strip():
        raise ValidationError("Experiment ID cannot be empty")

    exp_id = exp_id.strip()

    # Check for path traversal attempts first (more specific error message)
    if ".." in exp_id or "/" in exp_id or "\\" in exp_id:
        raise ValidationError(f"Invalid experiment ID: {exp_id}. Path traversal not allowed")

    # Must be alphanumeric + dash/underscore only
    if not re.match(r"^[a-zA-Z0-9_-]+$", exp_id):
        raise ValidationError(
            f"Invalid experiment ID: {exp_id}. "
            "Must contain only letters, numbers, dash, underscore"
        )

    # Reasonable length limit
    if len(exp_id) > 100:
        raise ValidationError(f"Experiment ID too long: {len(exp_id)} chars (max 100)")

    return exp_id


def validate_run_id(run_id: str) -> str:
    """Validate run ID format.

    Run IDs follow the format generated by Cloud Workflows:
    YYYYMMDD-HHMMSS-xxxxxxxx

    Where:
    - YYYYMMDD: 8-digit date (e.g., 20251107)
    - HHMMSS: 6-digit time (e.g., 143052)
    - xxxxxxxx: 8-character UUID prefix (lowercase hex)

    The validation also accepts user-defined alphanumeric IDs for local runs.

    Parameters
    ----------
    run_id : str
        Run ID to validate.

    Returns
    -------
    str
        Validated and trimmed run ID.

    Raises
    ------
    ValidationError
        If run_id is empty, has invalid format, or is too long.

    Examples
    --------
    >>> validate_run_id("20251107-143052-a1b2c3d4")
    '20251107-143052-a1b2c3d4'
    >>> validate_run_id("my-local-run-01")
    'my-local-run-01'
    >>> validate_run_id("2025-11-07")
    Traceback (most recent call last):
        ...
    ValidationError: Invalid run ID format: 2025-11-07. Expected
        YYYYMMDD-HHMMSS-xxxxxxxx or alphanumeric with dash/underscore
    """
    if not run_id or not run_id.strip():
        raise ValidationError("Run ID cannot be empty")

    run_id = run_id.strip()

    # Check for standard workflow format: YYYYMMDD-HHMMSS-xxxxxxxx
    workflow_pattern = r"^\d{8}-\d{6}-[a-f0-9]{8}$"
    if re.match(workflow_pattern, run_id):
        # Validate date and time components make sense
        date_part = run_id[:8]
        time_part = run_id[9:15]

        # Basic date validation (YYYYMMDD)
        year = int(date_part[:4])
        month = int(date_part[4:6])
        day = int(date_part[6:8])

        if year < 2020 or year > 2100:
            raise ValidationError(f"Invalid year in run ID: {year}")
        if month < 1 or month > 12:
            raise ValidationError(f"Invalid month in run ID: {month}")
        if day < 1 or day > 31:
            raise ValidationError(f"Invalid day in run ID: {day}")

        # Basic time validation (HHMMSS)
        hour = int(time_part[:2])
        minute = int(time_part[2:4])
        second = int(time_part[4:6])

        if hour > 23:
            raise ValidationError(f"Invalid hour in run ID: {hour}")
        if minute > 59:
            raise ValidationError(f"Invalid minute in run ID: {minute}")
        if second > 59:
            raise ValidationError(f"Invalid second in run ID: {second}")

        return run_id

    # Allow user-defined alphanumeric IDs (for local runs)
    if re.match(r"^[a-zA-Z0-9_-]+$", run_id):
        if len(run_id) > 100:
            raise ValidationError(f"Run ID too long: {len(run_id)} chars (max 100)")
        return run_id

    # Neither format matched
    raise ValidationError(
        f"Invalid run ID format: {run_id}. "
        "Expected YYYYMMDD-HHMMSS-xxxxxxxx or alphanumeric with dash/underscore"
    )


def validate_local_path(
    path: Path, must_exist: bool = True, must_be_dir: bool = False
) -> Path:
    """Validate local filesystem path.

    Resolves the path to absolute form and optionally checks existence.

    Parameters
    ----------
    path : Path
        Path to validate.
    must_exist : bool, default=True
        Require path to exist.
    must_be_dir : bool, default=False
        Require path to be a directory (only checked if path exists).

    Returns
    -------
    Path
        Validated, resolved absolute path.

    Raises
    ------
    ValidationError
        If path is invalid, doesn't exist (when required), or is not a
        directory (when required).

    Examples
    --------
    >>> validate_local_path(Path("."), must_exist=True, must_be_dir=True)
    PosixPath('/home/user/current-dir')
    >>> validate_local_path(Path("nonexistent"), must_exist=True)
    Traceback (most recent call last):
        ...
    ValidationError: Path does not exist: nonexistent
    """
    # Resolve to absolute path (handles symlinks, "..", etc.)
    try:
        resolved_path = path.resolve()
    except Exception as e:
        raise ValidationError(f"Invalid path: {path}. {e}")

    if must_exist and not resolved_path.exists():
        raise ValidationError(f"Path does not exist: {path}")

    if must_be_dir and resolved_path.exists() and not resolved_path.is_dir():
        raise ValidationError(f"Path is not a directory: {path}")

    return resolved_path


def validate_github_token(token: str) -> str:
    """Validate GitHub personal access token format.

    GitHub tokens start with specific prefixes depending on token type:
    - ghp_ : Classic personal access token
    - github_pat_ : Fine-grained personal access token
    - gho_ : OAuth access token
    - ghu_ : User-to-server token
    - ghs_ : Server-to-server token
    - ghr_ : Refresh token

    Parameters
    ----------
    token : str
        GitHub PAT to validate.

    Returns
    -------
    str
        Validated and trimmed token.

    Raises
    ------
    ValidationError
        If token is empty, has invalid format, or unusual length.

    Examples
    --------
    >>> validate_github_token("ghp_1234567890abcdef1234567890abcdef1234")
    'ghp_1234567890abcdef1234567890abcdef1234'
    >>> validate_github_token("github_pat_11AAAAAA0xxxxxxxxxxxxxxxxx_yyyyyyyyyyyyyyyyyy")
    'github_pat_11AAAAAA0xxxxxxxxxxxxxxxxx_yyyyyyyyyyyyyyyyyy'
    >>> validate_github_token("not-a-token")
    Traceback (most recent call last):
        ...
    ValidationError: Invalid GitHub token format. Expected to start with
        github_pat_, ghp_, gho_, ghu_, ghs_, or ghr_
    """
    if not token or not token.strip():
        raise ValidationError("GitHub token cannot be empty")

    token = token.strip()

    # GitHub tokens start with github_pat_, ghp_, gho_, etc.
    if not token.startswith(("github_pat_", "ghp_", "gho_", "ghu_", "ghs_", "ghr_")):
        raise ValidationError(
            "Invalid GitHub token format. "
            "Expected to start with github_pat_, ghp_, gho_, ghu_, ghs_, or ghr_"
        )

    # Reasonable length (GitHub PATs are typically 40-200 chars, fine-grained can be longer)
    if len(token) < 20 or len(token) > 300:
        raise ValidationError(f"GitHub token length unusual: {len(token)} chars")

    return token


def validate_stage_name(stage: str) -> str:
    """Validate pipeline stage name.

    Valid stage names are: builder, runner, output.

    Parameters
    ----------
    stage : str
        Stage name to validate.

    Returns
    -------
    str
        Validated stage name in lowercase.

    Raises
    ------
    ValidationError
        If stage name is invalid.

    Examples
    --------
    >>> validate_stage_name("builder")
    'builder'
    >>> validate_stage_name("RUNNER")
    'runner'
    >>> validate_stage_name("invalid")
    Traceback (most recent call last):
        ...
    ValidationError: Invalid stage name: invalid. Must be one of: builder, runner, output
    """
    if not stage or not stage.strip():
        raise ValidationError("Stage name cannot be empty")

    stage = stage.strip().lower()

    valid_stages = {"builder", "runner", "output"}
    if stage not in valid_stages:
        raise ValidationError(
            f"Invalid stage name: {stage}. Must be one of: {', '.join(sorted(valid_stages))}"
        )

    return stage
