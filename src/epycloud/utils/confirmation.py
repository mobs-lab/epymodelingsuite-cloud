"""Confirmation prompts for interactive command execution."""

from typing import Any

from epycloud.lib.output import Colors, colorize


def _heading(text: str) -> str:
    """Format a section heading with color.

    Parameters
    ----------
    text : str
        Heading text (without brackets)

    Returns
    -------
    str
        Colored heading with brackets
    """
    return colorize(f"[{text}]", Colors.CYAN)


def format_confirmation(info: dict[str, Any], mode: str) -> str:
    """Format confirmation information with sections.

    Parameters
    ----------
    info : dict[str, Any]
        Dictionary containing confirmation information
    mode : str
        Execution mode ('cloud' or 'local')

    Returns
    -------
    str
        Formatted confirmation message
    """
    lines = []
    exp_id = info.get("exp_id", "")
    run_id = info.get("run_id", "<auto-generated>")
    command_type = info.get("command_type", "workflow")  # 'workflow' or 'job'

    # Header
    if command_type == "workflow":
        if mode == "cloud":
            lines.append("Submit workflow")
        else:
            lines.append("Run workflow locally")
    else:  # job
        stage = info.get("stage", "")
        stage_name = {"A": "Builder", "B": "Runner", "C": "Output"}.get(stage, stage)
        if mode == "cloud":
            lines.append(f"Submit {stage_name} job")
        else:
            lines.append(f"Run {stage_name} locally")

    lines.append("")

    # [Configuration]
    lines.append(_heading("Configuration"))
    if "environment" in info:
        lines.append(f"  Environment: {info['environment']}")
    if "profile" in info:
        profile = info["profile"]
        # Handle both string and dict profile formats
        if isinstance(profile, dict):
            profile_name = profile.get("name", "unknown")
        else:
            profile_name = profile
        lines.append(f"  Profile: {profile_name}")
    lines.append("")

    if mode == "cloud":
        # [Google Cloud]
        lines.append(_heading("Google Cloud"))
        if "project_id" in info:
            lines.append(f"  Project: {info['project_id']}")
        if "region" in info:
            lines.append(f"  Region: {info['region']}")
        if "bucket_name" in info and command_type == "workflow":
            lines.append(f"  Bucket: gs://{info['bucket_name']}")
        lines.append("")

        # [GitHub] (workflow only)
        if command_type == "workflow":
            lines.append(_heading("GitHub"))
            if "modeling_suite_repo" in info and "modeling_suite_ref" in info:
                lines.append(
                    f"  epymodelingsuite repo: {info['modeling_suite_repo']}@{info['modeling_suite_ref']}"
                )
            if "forecast_repo" in info:
                lines.append(f"  Forecast repo: {info['forecast_repo']}")
            if "pat_configured" in info:
                pat_status = "✓ configured" if info["pat_configured"] else "✗ not configured"
                lines.append(f"  GitHub PAT: {pat_status}")
            lines.append("")

        # [Workflow Details] or [Job Details]
        if command_type == "workflow":
            lines.append(_heading("Workflow Details"))
            lines.append(f"  Experiment ID: {exp_id}")
            lines.append(f"  Run ID: {run_id}")
            if "max_parallelism" in info:
                lines.append(f"  Max parallelism: {info['max_parallelism']}")
            if "stage_b_machine_type" in info and info["stage_b_machine_type"]:
                override_marker = " (override)" if info.get("stage_b_machine_type_override") else ""
                lines.append(f"  Stage B machine type: {info['stage_b_machine_type']}{override_marker}")
            if "skip_output" in info:
                output_status = "disabled" if info["skip_output"] else "enabled"
                lines.append(f"  Stage C (output): {output_status}")
            if "storage_path" in info:
                lines.append(f"  Storage path: {info['storage_path']}")
        else:  # job
            stage = info.get("stage", "")
            stage_name = {"A": "Builder", "B": "Runner", "C": "Output"}.get(stage, stage)
            lines.append(_heading("Job Details"))
            lines.append(f"  Experiment ID: {exp_id}")
            lines.append(f"  Stage: {stage} ({stage_name})")
            lines.append(f"  Run ID: {run_id}")
            if "task_index" in info and stage == "B":
                lines.append(f"  Task index: {info['task_index']}")
            if "num_tasks" in info and stage == "C":
                lines.append(f"  Num tasks: {info['num_tasks']}")
        lines.append("")

        # [Resources] (job only)
        if command_type == "job":
            lines.append(_heading("Resources"))
            if "machine_type" in info:
                machine_type = info["machine_type"] if info["machine_type"] else "auto-select"
                lines.append(f"  Machine type: {machine_type}")
            if "max_duration_hours" in info:
                lines.append(f"  Max duration: {info['max_duration_hours']} hours")
            lines.append("")

        # [Docker Image]
        lines.append(_heading("Docker Image"))
        if "image_uri" in info:
            # Parse registry and image path from full URI
            # Format: registry/project/repo/image:tag
            parts = info["image_uri"].split("/", 1)
            if len(parts) == 2:
                registry = parts[0]
                image_path = parts[1]
                lines.append(f"  Registry: {registry}")
                lines.append(f"  Image: {image_path}")
            else:
                lines.append(f"  {info['image_uri']}")
        lines.append("")

    else:  # local mode
        # [Paths]
        lines.append(_heading("Paths"))
        lines.append("  Forecast: ./local/forecast/")
        if "storage_path" in info:
            lines.append(f"  Output: {info['storage_path']}")
        lines.append("")

        # [Workflow Details] or [Job Details]
        if command_type == "workflow":
            lines.append(_heading("Workflow Details"))
            lines.append(f"  Experiment ID: {exp_id}")
            lines.append(f"  Run ID: {run_id}")
            if "skip_output" in info:
                output_status = "disabled" if info["skip_output"] else "enabled"
                lines.append(f"  Stage C (output): {output_status}")
        else:  # job
            stage = info.get("stage", "")
            stage_name = {"A": "Builder", "B": "Runner", "C": "Output"}.get(stage, stage)
            lines.append(_heading("Job Details"))
            lines.append(f"  Experiment ID: {exp_id}")
            lines.append(f"  Stage: {stage} ({stage_name})")
            lines.append(f"  Run ID: {run_id}")
            if "task_index" in info and stage == "B":
                lines.append(f"  Task index: {info['task_index']}")
            if "num_tasks" in info and stage == "C":
                lines.append(f"  Num tasks: {info['num_tasks']}")
        lines.append("")

        # [Docker Image]
        lines.append(_heading("Docker Image"))
        if "image_name" in info and "image_tag" in info:
            lines.append(f"  Image: {info['image_name']}:{info['image_tag']}")
        lines.append("")

    return "\n".join(lines)


def prompt_confirmation(message: str, auto_confirm: bool = False) -> bool:
    """Display confirmation message and prompt for user input.

    Parameters
    ----------
    message : str
        Confirmation message to display
    auto_confirm : bool
        If True, skip prompt and auto-confirm

    Returns
    -------
    bool
        True if user confirms or auto_confirm is True, False otherwise
    """
    print(message)

    if auto_confirm:
        print("  → Auto-confirmed (--yes)")
        print()
        return True

    try:
        response = input("Continue? [y/N]: ").strip().lower()
        print()  # Add blank line after response
        return response in ["y", "yes"]
    except (EOFError, KeyboardInterrupt):
        print()  # Add blank line if interrupted
        return False
